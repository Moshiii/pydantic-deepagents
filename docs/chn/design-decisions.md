# 设计决策

pydantic-deep 中的架构选择、理由和权衡。

## 模块化架构

### 决策：后端独立包

**摘要**：后端实现在单独的包中（`pydantic-ai-backend`）。

**理由**（从代码推断）：
- 后端可在不同的代理框架中重用
- Docker 依赖是可选的（sandbox 额外功能）
- 清晰的关注点分离（存储 vs 代理逻辑）
- 允许独立的版本控制和开发

**权衡**：
- ✅ 跨项目可重用性
- ✅ 可选的 Docker 依赖
- ✅ 清晰的模块边界
- ❌ 额外的包依赖
- ❌ 潜在的版本不匹配问题

**考虑的替代方案**（隐含）：
- 在 pydantic-deep 中捆绑后端：会强制所有用户使用 Docker 依赖
- 多个后端包：过于细化，难以维护

**可见约束**：
- 后端实现必须实现 `BackendProtocol` 或 `SandboxProtocol`
- 后端是外部依赖，不是核心包的一部分

### 决策：Todo 工具集独立包

**摘要**：Todo 工具集在单独的包中（`pydantic-ai-todo`）。

**理由**（从代码推断）：
- Todo 功能对任何 pydantic-ai 代理都有用，不仅仅是 pydantic-deep
- 允许独立的开发和版本控制
- 可以在没有 pydantic-deep 的情况下独立使用

**权衡**：
- ✅ 可重用性
- ✅ 独立版本控制
- ✅ 独立使用
- ❌ 额外依赖
- ❌ 潜在的 API 漂移

**考虑的替代方案**（隐含）：
- 在 pydantic-deep 中捆绑：会限制可重用性
- 不提供 todo 功能：会降低框架价值

**可见约束**：
- 必须与 pydantic-ai 的工具集系统集成
- 必须与 `DeepAgentDeps` 配合进行状态管理

## 依赖注入

### 决策：DeepAgentDeps 作为运行时容器

**摘要**：所有运行时状态通过 `DeepAgentDeps` 数据类传递。

**理由**（从代码推断）：
- 无状态代理设计（代理可以在会话间共享）
- 配置（代理创建）和状态（运行时）的清晰分离
- 类型安全的依赖访问
- 易于为子代理克隆

**权衡**：
- ✅ 无状态代理（线程安全，可共享）
- ✅ 清晰的状态边界
- ✅ 类型安全
- ✅ 易于测试（模拟 deps）
- ❌ 必须在每次 agent.run() 调用中传递 deps
- ❌ 无全局状态（需要显式传递）

**考虑的替代方案**（隐含）：
- 全局状态：会破坏多用户场景
- 每代理状态：会阻止代理共享
- 上下文管理器：更复杂，不够明确

**可见约束**：
- `DeepAgentDeps` 必须传递给 `agent.run()`
- 工具集通过 `RunContext[DeepAgentDeps]` 访问 deps
- 子代理获得克隆的 deps（隔离上下文）

### 决策：通过协议的后端抽象

**摘要**：后端实现协议（`BackendProtocol`、`SandboxProtocol`）而不是继承。

**理由**（从代码推断）：
- 基于协议的设计允许多种后端类型
- 清晰的接口契约
- 易于交换实现
- 支持鸭子类型

**权衡**：
- ✅ 灵活的实现
- ✅ 清晰的契约
- ✅ 易于测试（模拟后端）
- ❌ 无共享实现（可能代码重复）
- ❌ 运行时类型检查（非编译时）

**考虑的替代方案**（隐含）：
- 抽象基类：灵活性较低，更严格
- 具体基类：会强制实现细节

**可见约束**：
- 后端必须实现协议方法
- 类型检查在运行时进行
- 无共享基础实现

## 工具集设计

### 决策：通过标志的可选工具集

**摘要**：工具集可以通过 `create_deep_agent()` 中的布尔标志启用/禁用。

**理由**（从代码推断）：
- 用户可能不需要所有工具集
- 减少令牌使用（更少的工具 = 更小的提示）
- 允许最小代理配置
- 清晰的选择加入/退出模型

**权衡**：
- ✅ 灵活性
- ✅ 减少令牌使用
- ✅ 最小配置
- ❌ 更多配置选项（复杂性）
- ❌ 必须知道要启用哪些工具集

**考虑的替代方案**（隐含）：
- 始终包含所有工具集：会增加令牌使用和复杂性
- 显式工具集列表：更冗长，不太方便

**可见约束**：
- 默认包含所有工具集（`include_* = True`）
- 工具集是独立的（可以混合和匹配）
- 工具集生成自己的系统提示部分

### 决策：动态系统提示

**摘要**：系统提示基于当前状态动态生成。

**理由**（从代码推断）：
- 上下文感知提示（上传、todos、代理可见的文件）
- 减少令牌使用（仅包含相关信息）
- 更好的代理性能（相关上下文）
- 状态变化时自动更新

**权衡**：
- ✅ 上下文感知
- ✅ 减少令牌
- ✅ 更好的性能
- ❌ 更复杂的提示生成
- ❌ 潜在的提示不一致

**考虑的替代方案**（隐含）：
- 静态提示：会包含不相关信息，浪费令牌
- 手动提示更新：容易出错，容易忘记

**可见约束**：
- 提示通过 `@agent.instructions` 装饰器生成
- 每个工具集提供自己的提示部分
- 提示在每次代理运行时自动更新

## 子代理设计

### 决策：隔离的子代理上下文

**摘要**：子代理获得克隆的 deps，todos 为空，无嵌套子代理。

**理由**（从代码推断）：
- 防止无限递归（子代理不能生成子代理）
- 隔离的任务执行（无对话历史）
- 共享文件系统（子代理可以读写文件）
- 清晰的任务边界

**权衡**：
- ✅ 防止递归
- ✅ 清晰的隔离
- ✅ 共享文件系统（对协调有用）
- ❌ 无对话上下文（子代理从头开始）
- ❌ 无嵌套委托

**考虑的替代方案**（隐含）：
- 完全上下文共享：会允许递归，增加复杂性
- 完全隔离：会阻止文件协调

**可见约束**：
- `clone_for_subagent()` 创建新的 deps，todos/subagents 为空
- 子代理共享后端和上传文件（文件访问）
- 子代理不共享消息历史

### 决策：按需子代理创建

**摘要**：子代理在首次使用时创建并缓存在 `deps.subagents` 中。

**理由**（从代码推断）：
- 延迟初始化（仅在需要时创建）
- 缓存减少创建开销
- 无状态子代理创建（如果需要可以重新创建）

**权衡**：
- ✅ 延迟初始化
- ✅ 性能（缓存）
- ✅ 无状态创建
- ❌ 内存使用（缓存的实例）
- ❌ 潜在的过时配置

**考虑的替代方案**（隐含）：
- 预创建所有子代理：如果未使用会浪费资源
- 无缓存：每次调用都会重新创建（低效）

**可见约束**：
- 子代理在 `task()` 工具实现中创建
- 缓存在 `ctx.deps.subagents` 字典中
- 可以预创建并在 deps 中传递

## 技能设计

### 决策：渐进式披露

**摘要**：技能首先加载 frontmatter，按需加载完整指令。

**理由**（从代码推断）：
- 减少初始加载时间（不解析所有技能）
- 节省令牌（仅在需要时加载指令）
- 更快的技能发现（仅元数据）
- 更好的可扩展性（许多技能，很少使用）

**权衡**：
- ✅ 快速发现
- ✅ 减少令牌
- ✅ 可扩展性
- ❌ 加载指令的额外步骤
- ❌ 潜在的不一致性（frontmatter vs 指令）

**考虑的替代方案**（隐含）：
- 预先加载所有指令：会慢且浪费
- 无 frontmatter：需要加载完整指令进行发现

**可见约束**：
- `discover_skills()` 仅加载 frontmatter
- `load_skill()` 加载完整指令
- 技能存储时带有 `frontmatter_loaded` 标志

### 决策：基于 Markdown 的技能格式

**摘要**：技能在带有 YAML frontmatter 的 SKILL.md 文件中定义。

**理由**（从代码推断）：
- 人类可读格式
- 易于版本控制
- 熟悉的格式（Markdown + YAML）
- 支持指令中的丰富格式

**权衡**：
- ✅ 人类可读
- ✅ 版本控制友好
- ✅ 丰富格式
- ❌ 手动解析（不使用完整 YAML 解析器）
- ❌ 有限验证

**考虑的替代方案**（隐含）：
- JSON 格式：可读性较差，更难编辑
- Python 模块：更复杂，需要执行
- 完整 YAML 解析器：会添加依赖，对简单格式过度

**可见约束**：
- 自定义 YAML frontmatter 解析器（简单 key:value 格式）
- frontmatter 后的 Markdown 指令
- 资源作为文件存储在技能目录中

## 历史处理

### 决策：近似令牌计数

**摘要**：令牌计数使用基于字符的启发式（约 4 个字符一个令牌）。

**理由**（从代码推断）：
- 无令牌化器依赖
- 快速计算
- 对阈值检测足够好
- 适用于所有模型

**权衡**：
- ✅ 无依赖
- ✅ 快速
- ✅ 模型无关
- ❌ 不精确（近似）
- ❌ 可能提前/延迟触发

**考虑的替代方案**（隐含）：
- 模型特定令牌化器：需要依赖，模型特定代码
- 精确计数：会更慢，需要令牌化器

**可见约束**：
- `_count_tokens_approximately()` 使用字符数 / 4
- 可以提供自定义令牌计数器
- 近似对阈值检测可接受

### 决策：安全截止点

**摘要**：摘要保留工具调用/响应对（不拆分它们）。

**理由**（从代码推断）：
- 工具调用需要它们的响应作为上下文
- 防止工具执行链断裂
- 保持对话连贯性

**权衡**：
- ✅ 保留工具上下文
- ✅ 保持连贯性
- ❌ 可能保留比请求更多的消息
- ❌ 更复杂的截止逻辑

**考虑的替代方案**（隐含）：
- 简单消息计数截止：会破坏工具对
- 始终保留工具对：会更简单但灵活性较低

**可见约束**：
- `_is_safe_cutoff_point()` 检查工具调用/响应对
- 在截止点周围搜索工具对
- 调整截止点以保留对

## 人在回路

### 决策：用于审批的 DeferredToolRequests

**摘要**：需要审批时工具返回 `DeferredToolRequests`，代理输出类型包含它。

**理由**（从代码推断）：
- 与 pydantic-ai 的审批系统集成
- 类型安全的审批工作流
- 可以与结构化输出结合（联合类型）
- 审批和执行的清晰分离

**权衡**：
- ✅ 类型安全
- ✅ 与 pydantic-ai 集成
- ✅ 灵活（可以与 output_type 结合）
- ❌ 更复杂的输出类型（联合）
- ❌ 必须在代码中处理 DeferredToolRequests

**考虑的替代方案**（隐含）：
- 基于回调：类型安全性较低
- 基于异常：会破坏控制流

**可见约束**：
- 使用 `interrupt_on` 时 `output_type` 变为联合
- 必须检查 `isinstance(result.output, DeferredToolRequests)`
- 审批结果通过 `deferred_tool_results` 参数传递

## 文件上传

### 决策：元数据跟踪

**摘要**：上传的文件跟踪元数据（大小、编码、行数、MIME 类型）。

**理由**（从代码推断）：
- 帮助代理理解文件内容
- 实现更好的文件处理决策
- 在系统提示中提供上下文
- 改善用户体验

**权衡**：
- ✅ 更好的代理理解
- ✅ 丰富的元数据
- ✅ 更好的提示
- ❌ 额外的处理开销
- ❌ 可能对某些文件类型失败

**考虑的替代方案**（隐含）：
- 无元数据：会降低代理能力
- 完整文件分析：会太慢

**可见约束**：
- 通过 `chardet` 进行编码检测（可能失败）
- 仅文本文件的行数
- 从文件名推断 MIME 类型（可能不准确）

## 结构化输出

### 决策：Pydantic 模型集成

**摘要**：结构化输出通过 `output_type` 参数使用 Pydantic 模型。

**理由**（从代码推断）：
- 类型安全响应
- 内置验证
- Python 开发者熟悉
- 与 pydantic-ai 集成

**权衡**：
- ✅ 类型安全
- ✅ 验证
- ✅ 熟悉的 API
- ❌ Pydantic 依赖
- ❌ 必须预先定义模型

**考虑的替代方案**（隐含）：
- JSON schema：类型安全性较低，更冗长
- 数据类：验证功能较少
- TypedDict：验证较少

**可见约束**：
- 必须使用 Pydantic 模型或兼容类型
- 验证在运行时进行
- 如果验证失败则出现类型错误
